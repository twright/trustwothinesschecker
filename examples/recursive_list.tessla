# Contents of this file:
# 1) Either implementation
# 2) Implementation of symbolic natural number with List, e.g., Suc(Suc...Suc((Z)))
# 3) Recursively defined List type: A symbolic representation that \st{utilizes} abuses the only recursive type in the language

##### 1) Either implementation  #####
type Either[L, R] := {isLeft : Bool, left : Option[L], right : Option[R]}
def left[L, R](val : L) : Either[L, R] = {isLeft = true, left = Some(val), right = None}
def right[L, R](val : R) : Either[L, R] = {isLeft = false, left = None, right = Some(val)}

##### 2) Symbolic natural number with List #####
type Nat = List[Unit]

def natCtorImpl(N : Int, res : Nat) : Nat = {
  if N == 0 then
    res
  else
    natCtorImpl(N-1, List.append(res, ()))
}

def natCtor(N : Int) : Nat = {
  natCtorImpl(N, List.empty())
}

###### 3) Recursively defined List type #####

# Rules: None means ], Some(None) means [, Some(Some(val)) means val
# NOTE: Final closing brackets are optional
type RListEl[T] = Option[Option[T]]
type RList[T] = List[RListEl[T]]

def open_bracket[T] : RListEl[T] = Some(None)
def closed_bracket[T] : RListEl[T] = None
def value[T](val : T) : RListEl[T] = Some(Some(val))

type RListElB = RListEl[Bool]
type RListB = RList[Bool]
type ZRListElB = (Int, RListElB)
def open_bracket_b = open_bracket[Bool]
def closed_bracket_b = closed_bracket[Bool]
def value_b(val : Bool) = value[Bool](val)
def get_list_el_b(val : RListElB) = getSome(getSome(val))

def serialize_rlist_b_impl_body(list : RListB, res : String, nest_level : Int) : String = {
  def h = List.head(list)
  def t = List.tail(list)
    if h == open_bracket_b then
      serialize_rlist_b_impl(List.tail(list), String.concat(res, "["), nest_level + 1)
    else if h == closed_bracket_b then
      serialize_rlist_b_impl(List.tail(list), String.concat(res, "], "), nest_level - 1)
    else
      if (List.size(list) == 1) || (List.head(t) == closed_bracket_b) then
        serialize_rlist_b_impl(List.tail(list), String.concat(res, String.format("%s", get_list_el_b(h))), nest_level)
      else
        serialize_rlist_b_impl(List.tail(list), String.concat(res, String.concat(String.format("%s", get_list_el_b(h)), ", ")), nest_level)
}

def serialize_rlist_b_impl_close_brackets(res : String, nest_level : Int) : String = {
  if nest_level == 1 then
    String.concat(res, "]")
  else
    serialize_rlist_b_impl_close_brackets(String.concat(res, "]"), nest_level - 1)
}

def serialize_rlist_b_impl(list : RListB, res : String, nest_level : Int) : String = {
  if List.isEmpty(list) then
    serialize_rlist_b_impl_close_brackets(res, nest_level)
  else
    serialize_rlist_b_impl_body(list, res, nest_level)
}

def serialize_rlist_b(list : RListB) : String = {
  serialize_rlist_b_impl(list, "[", 1)
}

# def remove_nested_lists_impl_body(list : RListB, remove : Bool) : RListB = {
#   def h = List.head(list)
#   def removing = remove_nested_lists_impl(List.tail(list), true)
#   def not_removing = remove_nested_lists_impl(List.tail(list), false)

#   if remove then # In removing state
#     if h == closed_bracket_b then
#       not_removing # Stop removing
#     else
#       removing # Keep removing
#   else
#     if h == open_bracket_b then
#       removing # Start removing
#     else
#       List.append(not_removing) # Add element, keep not removing
# }

# def remove_nested_lists_impl(list : RListB, rem : RListB, remove : Bool) : RListB = {
#   # Instead of this crap, make a function that returns unit if we are skipping the element and value if we keep it.

#   if List.isEmpty(list) then
#     list
#   else
#     List.append(list, remove_nested_lists_impl_body(rem, remove))
# }


def list_filter_impl[T](list : List[T], func : (T) => Bool, acc : List[T]) : List[T] = {
  if List.isEmpty(list) then
    acc
  else
    if func(List.head(list)) then
      list_filter_impl(List.tail(list), func, List.append(acc, List.head(list)))
    else
      list_filter_impl(List.tail(list), func, acc)
}

def list_filter[T](list : List[T], func : (T) => Bool) : List[T] = {
  list_filter_impl(list, func, List.empty())
}

def list_find_all[T](list : List[T], val : T) : List[(Int, T)] = {
  def with_idxs = List.zipWithIndex(list)
  list_filter[(Int, T)](with_idxs, (el) => el._2 == val)
}


# []
def test0 : RListB = List.empty()

# [true, false]
def test1 : RListB = {
  def l1 = List.append(List.empty(), value_b(true))
  List.append(l1, value_b(false))
}

# [true, [true]]
def test2 : RListB = {
  def l1 = List.append(List.empty, value_b(true))
  def l2 = List.append(l1, open_bracket_b)
  List.append(l2, value_b(true))
}

# [[], [true, [false]]]
def test3 : RListB = {
  def l1 = List.append(List.empty(), open_bracket_b)
  def l2 = List.append(l1, closed_bracket_b)
  def l3 = List.append(l2, open_bracket_b)
  def l4 = List.append(l3, value_b(true))
  def l5 = List.append(l4, open_bracket_b)
  List.append(l5, value_b(false))
}

# [[true], [false]]
def test4 : RListB = {
  def l1 = List.append(List.empty(), open_bracket_b)
  def l2 = List.append(l1, value_b(true))
  def l3 = List.append(l2, closed_bracket_b)
  def l4 = List.append(l3, open_bracket_b)
  List.append(l4, value_b(false))
}

# [[[[[[[[[[]]]]]]]]]]
def test5 : RListB = {
  List.append(List.append(List.append(List.append(List.append(List.append(List.append(List.append(List.append(List.empty(), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b)
}

#### Main:

def y = left[Int, Unit](42)
def z = right[Unit, Int](69)
def w = natCtor(0)

def serialize_test0 = serialize_rlist_b(test0) == "[]"
def serialize_test1 = serialize_rlist_b(test1) == "[true, false]"
def serialize_test2 = serialize_rlist_b(test2) == "[true, [true]]"
def serialize_test3 = serialize_rlist_b(test3) == "[[], [true, [false]]]"
def serialize_test4 = serialize_rlist_b(test4) == "[[true], [false]]"
def serialize_test5 = serialize_rlist_b(test5) == "[[[[[[[[[[]]]]]]]]]]"

def all_tests_passed = serialize_test0 && serialize_test1 && serialize_test2 && serialize_test3 && serialize_test4 && serialize_test5


out y
out z
out w
out all_tests_passed
out list_find_all[RListElB](test3, open_bracket_b) as tmp