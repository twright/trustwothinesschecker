# Contents of this file:
# 1) Either implementation
# 2) Implementation of symbolic natural number with List, e.g., Suc(Suc...Suc((Z)))
# 3) Recursively defined List type: A symbolic representation that \st{utilizes} abuses the only recursive type in the language

##### 1) Either implementation  #####
type Either[L, R] := {isLeft : Bool, left : Option[L], right : Option[R]}
def left[L, R](val : L) : Either[L, R] = {isLeft = true, left = Some(val), right = None}
def right[L, R](val : R) : Either[L, R] = {isLeft = false, left = None, right = Some(val)}

##### 2) Symbolic natural number with List #####
type Nat = List[Unit]

def natCtorImpl(N : Int, res : Nat) : Nat = {
  if N == 0 then
    res
  else
    natCtorImpl(N-1, List.append(res, ()))
}

def natCtor(N : Int) : Nat = {
  natCtorImpl(N, List.empty())
}

###### 3) Recursively defined List type #####

def list1[T](el : T) = List.append(List.empty(), el)

# Rules: None means ], Some(None) means [, Some(Some(val)) means val
# NOTE: Final closing brackets are optional
type RListEl[T] = Option[Option[T]]
type RList[T] = List[RListEl[T]]
# Unfortunately, need this in order to differentiate between head([true]) and head([[true]])
type RListHead[T] = {val : RList[T], isList : Bool}
def open_bracket[T] : RListEl[T] = Some(None)
def closed_bracket[T] : RListEl[T] = None
def value[T](val : T) : RListEl[T] = Some(Some(val))

type RListElB = RListEl[Bool]
type RListB = RList[Bool]
type RListHeadB = RListHead[Bool]
type ZRListElB = (Int, RListElB)
def open_bracket_b = open_bracket[Bool]
def closed_bracket_b = closed_bracket[Bool]
def value_b(val : Bool) = value[Bool](val)
def get_list_el_b(val : RListElB) = getSome(getSome(val))

def serialize_rlist_b_impl_body(list : RListB, res : String, nest_level : Int) : String = {
  def h = List.head(list)
  def t = List.tail(list)
    if h == open_bracket_b then
      serialize_rlist_b_impl(List.tail(list), String.concat(res, "["), nest_level + 1)
    else if h == closed_bracket_b then
      serialize_rlist_b_impl(List.tail(list), String.concat(res, "], "), nest_level - 1)
    else
      if (List.size(list) == 1) || (List.head(t) == closed_bracket_b) then
        serialize_rlist_b_impl(List.tail(list), String.concat(res, String.format("%s", get_list_el_b(h))), nest_level)
      else
        serialize_rlist_b_impl(List.tail(list), String.concat(res, String.concat(String.format("%s", get_list_el_b(h)), ", ")), nest_level)
}

def serialize_rlist_b_impl_close_brackets(res : String, nest_level : Int) : String = {
  if nest_level == 1 then
    String.concat(res, "]")
  else
    serialize_rlist_b_impl_close_brackets(String.concat(res, "]"), nest_level - 1)
}

def serialize_rlist_b_impl(list : RListB, res : String, nest_level : Int) : String = {
  if List.isEmpty(list) then
    serialize_rlist_b_impl_close_brackets(res, nest_level)
  else
    serialize_rlist_b_impl_body(list, res, nest_level)
}

def serialize_rlist_b(list : RListB) : String = {
  serialize_rlist_b_impl(list, "[", 1)
}


def list_filter_impl[T](list : List[T], func : (T) => Bool, acc : List[T]) : List[T] = {
  if List.isEmpty(list) then
    acc
  else
    if func(List.head(list)) then
      list_filter_impl(List.tail(list), func, List.append(acc, List.head(list)))
    else
      list_filter_impl(List.tail(list), func, acc)
}

def list_filter[T](list : List[T], func : (T) => Bool) : List[T] = {
  list_filter_impl(list, func, List.empty())
}

def list_find_all[T](list : List[T], val : T) : List[(Int, T)] = {
  def with_idxs = List.zipWithIndex(list)
  list_filter[(Int, T)](with_idxs, (el) => el._2 == val)
}


def list_pad[T](list : List[T], val : T, N : Int) : List[T] = {
  if N <= 0 then
    list
  else
    list_pad(List.append(list, val), val, N-1)
}


def forall[T](el : T, funcs : List[(T) => Bool]) : Bool = {
  if List.isEmpty(funcs) then
    true
  else
    List.head(funcs)(el) && forall(el, List.tail(funcs))
}

def merge_ranges_impl_body(ranges : List[(Int, Int)], acc : List[(Int, Int)]) : List[(Int, Int)] = {
  def h = List.head(ranges)
  def t = List.tail(ranges)
  def hh = List.head(t)
  if h._2 >= hh._2 then
    merge_ranges_impl(List.prepend(h, List.tail(t)), acc) # Remove hh from list and keep going with h
  else
    merge_ranges_impl(t, List.append(acc, h)) # Keep recursing from next element (append h to acc)
}

def merge_ranges_impl(ranges : List[(Int, Int)], acc : List[(Int, Int)]) : List[(Int, Int)] = {
  if List.isEmpty(ranges) then ranges
  else if List.size(ranges) == 1 then
    List.append(acc, List.head(ranges)) # Add the final range and return
  else
    merge_ranges_impl_body(ranges, acc)
}

# Assumes they are sorted
def merge_ranges(ranges : List[(Int, Int)]) : List[(Int, Int)] = {
  merge_ranges_impl(ranges, List.empty())
}

def rlist_size_b(list : RListB)  = {
  def open_bracket_idxs = List.map(list_find_all(list, open_bracket_b), (pair) => pair._1) # Find open brackets and return only idxs
  def closed_bracket_explicit_idxs = List.map(list_find_all(list, closed_bracket_b), (pair) => pair._1) # Find explicitly closed brackets and return only idxs

  def closed_bracket_idxs =
    if List.size(open_bracket_idxs) > List.size(closed_bracket_explicit_idxs) then
      list_pad(closed_bracket_explicit_idxs, List.size(list), List.size(open_bracket_idxs) - List.size(closed_bracket_explicit_idxs)) # Pad it with closed bracket
    else
      closed_bracket_explicit_idxs

  def bracket_ranges_full = List.zip(open_bracket_idxs, closed_bracket_idxs) # Might contain overlapping
  def bracket_ranges = merge_ranges(bracket_ranges_full)

  def with_idxs = List.zipWithIndex(list)

  def between_inclusive(min : Int, max : Int, el : ZRListElB) : Bool = el._1 >= min && el._1 <= max
  def not_between_range(range : (Int, Int)) : (ZRListElB) => Bool = ((el) => !between_inclusive(range._1, range._2, el))
  def interval_funcs = List.map(bracket_ranges, not_between_range)
  def not_between_intervals(el : ZRListElB) = forall(el, interval_funcs)
  def non_nested_els = list_filter(with_idxs, not_between_intervals)

  List.size(non_nested_els) + List.size(bracket_ranges)
}

# NOTE: Just like with normal head, running it on an empty list gives runtime error
def rlist_head(list : RListB) : RListHeadB = {
  def impl(list : RListB, acc : RListB, indent_level : Int) : RListB = {

    # Logic when we have no indent
    def body_no_indent(list : RListB, acc : RListB, indent_level : Int) : RListB = {
        def h = List.head(list)
        def t = List.tail(list)
        if h == open_bracket_b then
          impl(t, acc, indent_level + 1) # First indent means not adding the open bracket as it is built-in
        else
          List.append(acc, h)
    }

    # Logic when we have an indent
    def body_indent(list : RListB, acc : RListB, indent_level : Int) : RListB = {
        def h = List.head(list)
        def t = List.tail(list)
        if h == open_bracket_b then
          impl(t, List.append(acc, h), indent_level + 1)
        else if h == closed_bracket_b then
          if indent_level == 1 then # If this is final closed bracket
            acc
          else
            impl(t, List.append(acc, h), indent_level - 1)
        else
          impl(t, List.append(acc, h), indent_level)
    }

    if List.isEmpty(list) then
      acc
    else
      if indent_level == 0 then
        body_no_indent(list, acc, indent_level)
      else
        body_indent(list, acc, indent_level)
  }

  if List.head(list) == open_bracket_b then
    {val = impl(List.tail(list), List.empty(), 1), isList = true}
  else
    {val = list1(List.head(list)), isList = false}
}

# []
def test0 : RListB = List.empty()

# [true, false]
def test1 : RListB = {
  def l1 = List.append(List.empty(), value_b(true))
  List.append(l1, value_b(false))
}

# [true, [true]]
def test2 : RListB = {
  def l1 = List.append(List.empty, value_b(true))
  def l2 = List.append(l1, open_bracket_b)
  List.append(l2, value_b(true))
}

# [[], [true, [false]]]
def test3 : RListB = {
  def l1 = List.append(List.empty(), open_bracket_b)
  def l2 = List.append(l1, closed_bracket_b)
  def l3 = List.append(l2, open_bracket_b)
  def l4 = List.append(l3, value_b(true))
  def l5 = List.append(l4, open_bracket_b)
  List.append(l5, value_b(false))
}

# [[true], [false]]
def test4 : RListB = {
  def l1 = List.append(List.empty(), open_bracket_b)
  def l2 = List.append(l1, value_b(true))
  def l3 = List.append(l2, closed_bracket_b)
  def l4 = List.append(l3, open_bracket_b)
  List.append(l4, value_b(false))
}

# [[[[[[[[[[]]]]]]]]]]
def test5 : RListB = {
  List.append(List.append(List.append(List.append(List.append(List.append(List.append(List.append(List.append(List.empty(), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b)
}

#### Main:

def y = left[Int, Unit](42)
def z = right[Unit, Int](69)
def w = natCtor(0)

def serialize_test0 = serialize_rlist_b(test0) == "[]"
def serialize_test1 = serialize_rlist_b(test1) == "[true, false]"
def serialize_test2 = serialize_rlist_b(test2) == "[true, [true]]"
def serialize_test3 = serialize_rlist_b(test3) == "[[], [true, [false]]]"
def serialize_test4 = serialize_rlist_b(test4) == "[[true], [false]]"
def serialize_test5 = serialize_rlist_b(test5) == "[[[[[[[[[[]]]]]]]]]]"

def size_test0 = rlist_size_b(test0) == 0
def size_test1 = rlist_size_b(test1) == 2
def size_test2 = rlist_size_b(test2) == 2
def size_test3 = rlist_size_b(test3) == 2
def size_test4 = rlist_size_b(test4) == 2
def size_test5 = rlist_size_b(test5) == 1

# def head_test0 = rlist_head(test0) # Runtime error
def head_test1 = rlist_head(test1) == {isList = false, val = list1(Some(Some(true)))}
def head_test2 = rlist_head(test2) == {isList = false, val = list1(Some(Some(true)))}
def head_test3 = rlist_head(test3) == {isList = true, val = List.empty()}
def head_test4 = rlist_head(test4) == {isList = true, val = list1(Some(Some(true)))}
def head_test5 = rlist_head(test5) == {isList = true, val = List.append(List.append(List.append(List.append(List.append(List.append(List.append(List.append(List.empty(), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b), open_bracket_b)}

def all_serialize_tests_passed = serialize_test0 && serialize_test1 && serialize_test2 && serialize_test3 && serialize_test4 && serialize_test5
def all_size_tests_passed = size_test0 && size_test1 && size_test2 && size_test3 && size_test4 && size_test5
def all_head_tests_passed = head_test1 && head_test2 && head_test3 && head_test4 && head_test5

out y
out z
out w
out all_serialize_tests_passed
out all_size_tests_passed
out all_head_tests_passed